extends Node3D

# ============================================================================
# MARCHING CUBES — DETAILED IMPLEMENTATION OVERVIEW
# ============================================================================
#
# Marching Cubes converts a 3D scalar field (density values on a grid)
# into a triangle mesh representing an iso-surface (usually density == 0).
#
# The algorithm works on one cube cell at a time. Each cube consists of
# 8 corner sample points and 12 edges.
#
# Source for triangle and edge tables: https://paulbourke.net/geometry/polygonise/
#
# ---------------------------------------------------------------------------
# 1. DENSITY FIELD
# ---------------------------------------------------------------------------
# The density function defines a continuous scalar field:
#
#     get_density(x, y, z) -> float
#
# By convention:
#   density < 0 : inside solid
#   density = 0 : surface
#   density > 0 : empty space
#
# Examples:
#   Plane:   density = y - height
#   Sphere:  density = distance_to_center - radius
#
# The iso-surface is extracted where density crosses zero.
#
# ---------------------------------------------------------------------------
# 2. GRID AND CUBE DEFINITION
# ---------------------------------------------------------------------------
# The volume is discretized into a regular 3D grid.
# Each grid cell forms a cube with 8 corners:
#
#   Corner indices and positions:
#
#       7 ------ 6
#      /|       /|
#     4 ------ 5 |
#     | |      | |
#     | 3 ------ 2
#     |/       |/
#     0 ------ 1
#
# Corner index mapping:
#   0: (0,0,0)   1: (1,0,0)
#   2: (1,0,1)   3: (0,0,1)
#   4: (0,1,0)   5: (1,1,0)
#   6: (1,1,1)   7: (0,1,1)
#
# Each cube is evaluated independently.
#
# ---------------------------------------------------------------------------
# 3. CUBE INDEX (TOPOLOGY CLASSIFICATION)
# ---------------------------------------------------------------------------
# For each cube, the density at its 8 corners is sampled.
#
# A cube_index (0..255) is built by treating each corner as a bit:
#
#   bit i = 1 if density[i] < ISO_LEVEL
#   bit i = 0 otherwise
#
# This 8-bit number uniquely identifies the topological case of the cube.
#
# Example:
#   cube_index = 0b00101101
#
# ---------------------------------------------------------------------------
# 4. EDGE TABLE (WHICH EDGES ARE INTERSECTED)
# ---------------------------------------------------------------------------
# EDGE_TABLE[cube_index] returns a 12-bit bitmask.
#
# Each bit corresponds to one of the 12 cube edges:
#   bit n == 1 → the iso-surface crosses edge n
#
# If the bitmask is 0, the cube contains no surface and is skipped.
#
# ---------------------------------------------------------------------------
# 5. EDGE → CORNER MAPPING
# ---------------------------------------------------------------------------
# Each of the 12 edges connects two cube corners:
#
#   Edge 0:  0 - 1
#   Edge 1:  1 - 2
#   Edge 2:  2 - 3
#   Edge 3:  3 - 0
#   Edge 4:  4 - 5
#   Edge 5:  5 - 6
#   Edge 6:  6 - 7
#   Edge 7:  7 - 4
#   Edge 8:  0 - 4
#   Edge 9:  1 - 5
#   Edge 10: 2 - 6
#   Edge 11: 3 - 7
#
# This mapping is used to locate where the surface crosses the cube.
#
# ---------------------------------------------------------------------------
# 6. EDGE INTERPOLATION (VERTEX GENERATION)
# ---------------------------------------------------------------------------
# For each intersected edge, a vertex is generated by interpolating
# between the two corner positions based on their density values.
#
# Linear interpolation ensures continuity across neighboring cubes:
#
#   t = d0 / (d0 - d1)
#   vertex = p0 + t * (p1 - p0)
#
# Vertices are stored in an array of size 12, indexed by edge number.
#
# ---------------------------------------------------------------------------
# 7. TRIANGULATION TABLE (CONNECTING VERTICES)
# ---------------------------------------------------------------------------
# TRI_TABLE[cube_index] contains a list of edge indices.
#
# Every group of 3 indices defines one triangle.
# The list is terminated by -1.
#
# Example:
#   [1, 8, 3, 9, 8, 1, -1, ...]
#
# means:
#   Triangle 1: edges (1, 8, 3)
#   Triangle 2: edges (9, 8, 1)
#
# The edge indices are used to look up the previously interpolated vertices.
#
# ---------------------------------------------------------------------------
# 8. MESH EMISSION
# ---------------------------------------------------------------------------
# For each triangle:
#   - Vertices are appended to the mesh vertex buffer
#   - Indices are emitted in order
#
# The result is a triangle mesh approximating the iso-surface.
#
# ---------------------------------------------------------------------------
# 9. IMPORTANT NOTES
# ---------------------------------------------------------------------------
# • All tables (EDGE_TABLE, TRI_TABLE, edge-to-corner mapping) must use
#   the same corner and edge ordering.
#
# • Grid spacing must be uniform (unit spacing assumed here).
#
# • Proper interpolation is REQUIRED for continuity.
#
# • Normals should be generated from the density gradient for correct lighting.
#
# ---------------------------------------------------------------------------
# END OF MARCHING CUBES OVERVIEW
# ============================================================================


@onready var mesh_instance := $MeshInstance3D
@onready var static_body := $StaticBody3D
@onready var collision_shape := $StaticBody3D/CollisionShape3D

const SIZE_X           := 16
const SIZE_Y           := 16
const SIZE_Z           := 16
const ISO_LEVEL        := +0.0
const AIR              := +1.0  # or any positive value = outside
const SOLID            := -1.0
const DEBUG            := false
const DEBUG_MESH       := false
const BRUSH_RADIUS     := 2
const DEFAULT_MATERIAL := 0

# We store materials on grid points and interpolate to vertex colours in the first step
# Alternatively one could colour the generated verticles which would be more precise
# This could be a layer on top (i.e. material with a paint on top)
var density_field      := {} # Dictionary<Vector3i, float>
var material_id_field  := {} # Dictionary<Vector3i, int>

# Let's make this a texture lookup later
var material_palette := {
	0: INFERNO_COLORS[0],
	1: INFERNO_COLORS[1],
	2: INFERNO_COLORS[2],
	3: INFERNO_COLORS[3],
	4: INFERNO_COLORS[4],
	5: INFERNO_COLORS[5],
}

const INFERNO_COLORS := [
	Color(0.000, 0.000, 0.016),  # very dark
	Color(0.259, 0.039, 0.408),
	Color(0.576, 0.149, 0.404),
	Color(0.867, 0.318, 0.227),
	Color(0.988, 0.647, 0.039),
	Color(0.988, 1.000, 0.643),  # bright
]



func dbg(x, y, z) -> bool:
	return DEBUG

# Getters and setters for material and density fields
# Index the density and material fields using integers only
func get_density(p: Vector3i) -> float:
	return density_field.get(p, AIR)

func get_material(p: Vector3i) -> int:
	return material_id_field.get(p, DEFAULT_MATERIAL)

func set_density(p: Vector3i, value):
	if value > 0.0:
		density_field.erase(p)
	else:
		density_field[p] = value

func set_material(p: Vector3i, value):
	if density_field.has(p):
		material_id_field[p] = value


func init_density():
	var center = Vector3(8, 8, 8)
	var radius = 6.0

	for x in range(0, 16):
		for y in range(0, 16):
			for z in range(0, 16):
				var p = Vector3i(x, y, z)
				var d = p.distance_to(center) - radius
				if d < 0.0:
					set_density(p, d)

func has_density(p: Vector3i) -> bool:
	return density_field.has(p)

func is_ground(p: Vector3i) -> bool:
	return p.y == 0

func is_within_bounding_box(p: Vector3i) -> bool:
	return (p.x > 0 && p.x < SIZE_X - 1) && (p.y >= 0 && p.y < SIZE_Y - 1) && (p.z > 0 && p.z < SIZE_Z -1)


func add_density_world(world_pos: Vector3, strength: float, radius: float, material_id: int = DEFAULT_MATERIAL, command: VoxelBrushCommand = null):
	var center := Vector3i(
		floor(world_pos.x),
		floor(world_pos.y),
		floor(world_pos.z)
	)
	var r   := int(ceil(radius))
	var r_f := float(radius)

	for x in range(center.x - r, center.x + r + 1):
		for y in range(center.y - r, center.y + r + 1):
			for z in range(center.z - r, center.z + r + 1):
				var p := Vector3i(x, y, z)
				var d := Vector3(p).distance_to(world_pos)

				# Check whether point is within brush radius and bounding box
				if d > r_f or not is_within_bounding_box(p):
					continue


				# Calculate new density and material fields and record change
				var old_density  := get_density(p)
				var old_material := get_material(p)

				if command:
					command.record_before(p, old_density, old_material)

				var falloff      := 1.0 - (d / r_f)
				var delta        := strength * falloff
				var new_density  := old_density + delta
				var new_material := material_id

				if command:
					command.record_after(p, new_density, new_material)

				# Update density and material fields
				set_density(p, new_density)
				set_material(p, new_material)

	generate_mesh()


# Sample cube corners
# The numbers 0-7 can be written as a 3 -bit number like 000, 001, 010 and so on
# Each bit tells you whether that corner is offset by +1 along an axis
# That would give us the following mapping
#      z
#      ↑
#      |
#      6 -------- 7
#     /|         /|
#    / |        / |
#   4 -------- 5  |
#   |  |       |  |
#   |  2 ------|--3   → y
#   | /        | /
#   |/         |/
#   0 -------- 1
#        →
#        x
#
# 0 : (0,0,0)
# 1 : (1,0,0)
# 2 : (0,1,0)
# 3 : (1,1,0)
# 4 : (0,0,1)
# 5 : (1,0,1)
# 6 : (0,1,1)
# 7 : (1,1,1)
#
# However, our TRIANGLE_TABLE requires the following layout
#       z
#       ↑
#        |
#        7 -------- 6
#       /|         /|
#      / |        / |
#     4 -------- 5  |
#     |  |       |  |
#     |  3 ------|--2   → y
#     | /        | /
#     |/         |/
#     0 -------- 1
#          →
#          x
#
# 0 : (0,0,0)
# 1 : (1,0,0)
# 2 : (1,1,0)
# 3 : (0,1,0)
# 4 : (0,0,1)
# 5 : (1,0,1)
# 6 : (1,1,1)
# 7 : (0,1,1)

# We need to map between them
const BOURKE_CORNER_MAP = [
	0, # 0 -> 0
	1, # 1 -> 1
	3, # 2 -> 3
	2, # 3 -> 2
	4, # 4 -> 4
	5, # 5 -> 5
	7, # 6 -> 7
	6  # 7 -> 6
]

func cube_corner_offset(i: int) -> Vector3i:
	var j = BOURKE_CORNER_MAP[i]
	return Vector3i(
		(j & 1) != 0,
		(j & 2) != 0,
		(j & 4) != 0
	)

# How are triangles formed?
# TRI_TABLE has 256 entries and maps each of the 256 distinct cube topologies in marching cubes to the required triangles
# For case 2, vertices on the edges 0, 8 and 3 are used to describe a single triangle
const TRI_TABLE = [
	[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
	[3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
	[3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
	[3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
	[9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
	[9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
	[2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
	[8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
	[9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
	[4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
	[3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
	[1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
	[4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
	[4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
	[9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
	[5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
	[2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
	[9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
	[0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
	[2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
	[10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
	[4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
	[5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
	[5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
	[9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
	[0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
	[1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
	[10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
	[8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
	[2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
	[7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
	[9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
	[2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
	[11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
	[9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
	[5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
	[11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
	[11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
	[1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
	[9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
	[5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
	[2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
	[0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
	[5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
	[6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
	[3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
	[6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
	[5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
	[1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
	[10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
	[6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
	[8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
	[7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
	[3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
	[5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
	[0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
	[9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
	[8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
	[5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
	[0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
	[6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
	[10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
	[10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
	[8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
	[1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
	[3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
	[0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
	[10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
	[3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
	[6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
	[9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
	[8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
	[3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
	[6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
	[0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
	[10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
	[10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
	[2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
	[7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
	[7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
	[2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
	[1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
	[11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
	[8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
	[0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
	[7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
	[10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
	[2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
	[6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
	[7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
	[2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
	[1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
	[10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
	[10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
	[0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
	[7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
	[6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
	[8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
	[9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
	[6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
	[4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
	[10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
	[8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
	[0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
	[1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
	[8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
	[10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
	[4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
	[10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
	[5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
	[11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
	[9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
	[6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
	[7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
	[3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
	[7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
	[9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
	[3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
	[6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
	[9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
	[1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
	[4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
	[7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
	[6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
	[3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
	[0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
	[6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
	[0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
	[11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
	[6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
	[5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
	[9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
	[1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
	[1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
	[10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
	[0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
	[5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
	[10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
	[11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
	[9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
	[7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
	[2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
	[8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
	[9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
	[9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
	[1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
	[9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
	[9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
	[5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
	[0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
	[10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
	[2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
	[0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
	[0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
	[9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
	[5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
	[3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
	[5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
	[8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
	[0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
	[9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
	[0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
	[1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
	[3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
	[4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
	[9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
	[11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
	[11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
	[2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
	[9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
	[3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
	[1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
	[4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
	[4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
	[0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
	[3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
	[3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
	[0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
	[9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
	[1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
	[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
]

# Which edges are crossed?
# Each cube is 12 edges.
# EDGE_TABLE is a 12-bit mask telling you which of the cube's 12 edges are intersected by the iso-surface
# There is one entry for each of the 256 distinct cube topologies
# For instance, the second entry indicates that the edges 0, 3 and 8 are intersected
# 0x109 = 0001 0000 1001 (binary)
#            ^    ^    ^
#            8    3    0
# EDGE_TABLE is a performance optimisation - it enables us to interpolate only edges that are actually used
const EDGE_TABLE = [
	0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
	0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
	0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
	0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
	0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
	0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
	0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
	0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
	0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
	0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
	0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
	0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
	0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
	0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
	0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
	0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
	0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
	0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
	0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
	0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
	0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
	0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
	0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
	0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
	0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
	0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
	0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
	0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
	0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
	0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
	0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
	0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
]
# Maps an edge to the two points it connects
# For instance, edge 3 connects corners 3 and 0
var EDGE_TO_POINTS = [
	[0,1],[1,2],[2,3],[3,0],
	[4,5],[5,6],[6,7],[7,4],
	[0,4],[1,5],[2,6],[3,7]
]

func _ready():
	init_density()
	generate_mesh()


func generate_mesh():
	var vertices: PackedVector3Array = []
	var normals: PackedVector3Array = []
	var indices:  PackedInt32Array   = []
	var colors:   PackedColorArray   = []

	var index := 0

	for x in range(SIZE_X - 1):
		for y in range(SIZE_Y - 1):
			for z in range(SIZE_Z - 1):
				var before := vertices.size()
				march_cube(x, y, z, vertices, normals, colors)
				var after := vertices.size()
				if DEBUG_MESH:
					print("cube (", x, y, z, ") emitted ", (after - before) / 3, " triangles")


	if DEBUG_MESH:
		print("total vertices:", vertices.size())
		print("total triangles:", vertices.size() / 3)

		for i in range(vertices.size()):
			print("v[", i, "] = ", vertices[i])

	var arrays := []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = vertices
	arrays[Mesh.ARRAY_NORMAL] = normals
	arrays[Mesh.ARRAY_COLOR]  = colors
	#arrays[Mesh.ARRAY_INDEX] = indices

	var mesh := ArrayMesh.new()
	mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
	mesh_instance.mesh = mesh

	# Update collision
	if mesh.get_surface_count() == 0:
		collision_shape.shape = null
		return

	collision_shape.shape = mesh.create_trimesh_shape()

	# Enable vertex colours
	if mesh_instance.material_override == null:
		var mat := StandardMaterial3D.new()
		mat.vertex_color_use_as_albedo = true
		mesh_instance.material_override = mat



func march_cube(x, y, z, vertices, normals, colors):
	var cube = []


	for i in range(8):
		var p_i = Vector3i(x, y, z) + cube_corner_offset(i)
		var d   = get_density(p_i)
		cube.append(d)

	# Check whether densities at corners are above ISO_LEVEL threshold
	# cube_index is an 8-bit number where each bit indicates whether corner i is inside the surface
	# Set i-th bit in cube_index to indicate that corner is present
	var cube_index := 0
	for i in range(8):
		if cube[i] > ISO_LEVEL:
			cube_index |= (1 << i)

 	# Check which edges are crossed by cube surface
	# Edges are crossed because they connect two corners
	# One corner has density lower than the isosurface
	# The other is above
	# So the surface intersects the edge
	var edges = EDGE_TABLE[cube_index]
	if edges == 0:
		return

	var vert_list  = []
	var color_list = []
	var normal_list = []
	vert_list.resize(12)
	color_list.resize(12)
	normal_list.resize(12)

	# Interpolate edges that are crossed
	# At this stage, the algorithm only knows that the cube surface crosses a given edge somewhere
	# But it does not know.
	# Where on the edge
	# How far from either corner
	# How to connect neighboring cubes consistently
	for edge in range(12):
		if edges & (1 << edge):
			var res          = interpolate_edge_with_color(Vector3i(x, y, z), edge)
			vert_list[edge]  = res.pos
			color_list[edge] = res.color
			normal_list[edge] = sample_gradient(res.pos)

			if dbg(x,y,z):
				if is_nan(res.pos.x) or is_nan(res.pos.y) or is_nan(res.pos.z):
					print("!!! NaN vertex on edge ", edge)
				else:
					print("edge ", edge,
						" vertex=", res.pos
					)
	# Iterate over vertices
	var i := 0
	var flip := false
	while TRI_TABLE[cube_index][i] != -1:

		var i0 = TRI_TABLE[cube_index][i]
		var i1 = TRI_TABLE[cube_index][i + 1]
		var i2 = TRI_TABLE[cube_index][i + 2]

		var a  = vert_list[i0]
		var b  = vert_list[i1]
		var c  = vert_list[i2]

		var na = normal_list[i0]
		var nb = normal_list[i1]
		var nc = normal_list[i2]

		var c1 = color_list[i0]
		var c2 = color_list[i1]
		var c3 = color_list[i2]

		if dbg(x,y,z):
			print("triangle: edges ", i0, ",", i1, ",", i2)
			print("  A=", a)
			print("  B=", b)
			print("  C=", c)
			print("  C1=", c1)
			print("  C2=", c2)
			print("  C3=", c3)
			# Degeneracy check
			if a == b or b == c or a == c:
				print("  !!! degenerate triangle")

		# Note that the order of insertion is important for the direction of the normal vectors
		# Correct normal vectors require a, c, b
		vertices.append(a)
		vertices.append(c)
		vertices.append(b)

		normals.append(na)
		normals.append(nc)
		normals.append(nb)

		colors.append(c1)
		colors.append(c3)
		colors.append(c2)

		i += 3


func material_id_to_color(id: int) -> Color:
	return material_palette.get(id, INFERNO_COLORS[0])

func sample_material_color(p: Vector3i):
	if not density_field.has(p):
		return null # signal "no material"
	return material_id_to_color(get_material(p))

# Minimal version: Constant interpolation
# Assume that vertex of surface lies at midpoint between corners
func interpolate_edge_constant(base: Vector3i, edge: int):
	var p1 = Vector3(cube_corner_offset(EDGE_TO_POINTS[edge][0]))
	var p2 = Vector3(cube_corner_offset(EDGE_TO_POINTS[edge][1]))

	return base + (p1 + p2) * 0.5

# Linear interpolation
# Assume that vertex of surface lies at density-weighted midpoint of corners
func interpolate_edge(base: Vector3i, edge: int):
	var c0 = EDGE_TO_POINTS[edge][0]
	var c1 = EDGE_TO_POINTS[edge][1]

	var p0_i = base + cube_corner_offset(c0)
	var p1_i = base + cube_corner_offset(c1)

	var p0  = Vector3(p0_i)
	var p1  = Vector3(p1_i)

	var d0 = get_density(p0_i)
	var d1 = get_density(p1_i)

	var t = (d0 - ISO_LEVEL) / (d0 - d1)
	return p0 + t * (p1 - p0)

func interpolate_edge_with_color(base: Vector3i, edge: int):
	var c0 = EDGE_TO_POINTS[edge][0]
	var c1 = EDGE_TO_POINTS[edge][1]

	var p0_i = base + cube_corner_offset(c0)
	var p1_i = base + cube_corner_offset(c1)

	var p0  = Vector3(p0_i)
	var p1  = Vector3(p1_i)

	var d0 = get_density(p0_i)
	var d1 = get_density(p1_i)

	var t = (d0 - ISO_LEVEL) / (d0 - d1)

	# Interpolated position
	var pos = p0 + t * (p1 - p0)

	# Interpolated color
	var col0 = sample_material_color(p0_i)
	var col1 = sample_material_color(p1_i)

	var col: Color
	if col0 == null and col1 == null:
		col = INFERNO_COLORS[0] # fallback, should not really happen
	elif col0 == null:
		col = col1
	elif col1 == null:
		col = col0
	else:
		col = col0.lerp(col1, t)


	return { "pos": pos, "color": col }
	
func sample_gradient(p: Vector3) -> Vector3:
	var pi = Vector3i(round(p.x), round(p.y), round(p.z))
	var eps := 1.0

	var dx = get_density(Vector3i(pi + Vector3i(eps, 0, 0))) \
		   - get_density(Vector3i(pi - Vector3i(eps, 0, 0)))
	var dy = get_density(Vector3i(pi + Vector3i(0, eps, 0))) \
		   - get_density(Vector3i(pi - Vector3i(0, eps, 0)))
	var dz = get_density(Vector3i(pi + Vector3i(0, 0, eps))) \
		   - get_density(Vector3i(pi - Vector3i(0, 0, eps)))

	return Vector3(dx, dy, dz).normalized()
